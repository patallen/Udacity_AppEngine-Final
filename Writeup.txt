TASK 2:
Added Session model
Session is a child of conference - all sessions in a conferenced can be easily queried with ancestor query.

Added SessionForm as well as SessionForms for returning multiple sessions.

Choices for Session model:
Name is required
Speaker is required (must have a speaker for each session and will be queried on later)
	- Could have used a full fledged entity (new model/forms) for speakers, 
	- Left speaker as string for proof of concept.
Duration - duration of the session. Opted to go for time in minutes (this will be query-able later on)
typeOfSession - I wasn't exactly sure how to implement this... I went with an enum class, much like the TeeShirtSize in profile.
	- Can only specify certain types
	- Can call the class as a list? to check if values valid
Date - Stored in the DB as a date object, presented as string
Time - Stored in the DB as time object, presented as string (will be queried on later)

websafekey - not stored in db, but computed in SessionForm.

TASK 3:
Additional queries:
	- getSessionsByType - query all sessions accross all conferences by type
	sessions = Session.query(Session.typeOfSession == 'WORKSHOP')
	- getConferencesByCategory - query for all conferences with a specific category
	sessions = Session.query(Session.category = 'Programming Languages')

PROBLEM WITH QUERY:
	- Only one inequality filter is supported with google datastore.
		- Can query by typeOfSession equal to everything but WORKSHOP ex:
			Session.query(
				ndb.AND(
					ndb.OR(Session.typeOfSession == 'NOT_SPECIFIED',
						Session.typeOfSession == 'KEYNOTE',
						Session.typeOfSession == 'FREEFORM',
						Session.typeOfSession == 'LECTURE'
						), Session.startTime < datetime.strptime('19:00', '%H:%M').time())
				)

		- Could programatically exclude sessions with type of 'WORKSHOP'
